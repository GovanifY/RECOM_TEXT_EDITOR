! function() {
    //NO UNDECLARED VARS AND SHITS LIKE THIS PLEASE.
    "use strict";

    AbstractEditor.settings.name = "RECOM Text Editor", AbstractEditor.settings.version = "1.00.10", AbstractEditor.settings.defaultEncoding = "KH Re: Chain of Memories English";
    //Debug flag
    var e = -1 !== document.location.search.search(/[?&]debug([=&]|$)/i),
    //No optimize flag, used for not optimizing BAR files when saving.
    t = -1 !== document.location.search.search(/[?&]debug_nooptimize([=&]|$)/i),
        
        //Function used for swapping bytes. OK
        SwapBytes = function(e) {
            return new Uint8Array([255 & e, e >>> 8 & 255, e >>> 16 & 255, e >>> 24 & 255])
        },

        i = function(e, t) {
            if (e.length !== t.length) return !1;
            for (var n = e.length; --n >= 0;)
                if (e[n] !== t[n]) return !1;
            return !0
        },

        //Used for parsing RE:COM CTD format (not packed!)
        ParseCTD = function(CTDBinary) {
            var sector = 0;
            CTDBinary.sections[sector] = {
                parent: CTDBinary,
                changed: !1,
                changedC: !1,
                changedV: !1,
                linked: []
            }
            var Strings = "";
            //Let's open a BinaryReader of this BAR file.
            var CTDReader = new jDataView(CTDBinary.rawData, void 0, void 0, !0);
            if ((CTDBinary.rawData.byteLength || CTDBinary.rawData.length) < 16 || 1146372928 !== CTDReader.getUint32()) return "Invalid header!"; //CTD Header: [0x40, 0x43, 0x54, 0x44]
            var Flag = !1;
            var ParamNumbers = CTDReader.getUint16();
            var Count = CTDReader.getUint16();
            var LBAPointer = CTDReader.getUint32();
            var TextPointer = CTDReader.getUint32();
            
            for (var i = 0; i < ParamNumbers; i++) {
                CTDReader.getUint32();
                CTDReader.getUint32();
                CTDReader.getUint32();
                CTDReader.getUint32();
                CTDReader.getUint32();
                CTDReader.getUint16();
                CTDReader.getUint16();
                CTDReader.getUint16();
                CTDReader.getUint16();
                CTDReader.getUint16();
                CTDReader.getUint16();

                CTDReader.getUint32();
                CTDReader.getUint32();
                CTDReader.getUint32();
                CTDReader.getUint32();//Those are not params and are yet unknown.
            }

            CTDReader.seek(LBAPointer);

            for (var i = 0; i < Count; i++) {
                var TextPlace = TextPointer + CTDReader.getUint32();
                var positionner = CTDReader.tell();
                CTDReader.seek(TextPlace);
                
                var Flag = !1;
                var tocontinue = !1;
                var FirstByte;
                var tobreak = !0;
                while(tocontinue === !1)
                {
                    if (tobreak === !1) {break;}
                var bytetext = CTDReader.getUint8();
                if (0 === bytetext)
                { 
                    tobreak = !1;
                }
                Strings += (FirstByte ? "" : " ") + ("0" + bytetext.toString(16)).slice(-2)
                if (tobreak === !1) {Strings += "\n";}
                FirstByte = !1;
                arrTypesParse.khrecom(bytetext);

                }
                Flag = !0;
                CTDReader.seek(positionner);
            }
            CTDBinary.sections[sector].hex = Strings;
            e && console.log("HERE IS DA STRING:" + Strings);
            return Flag ? void 0 : "No string tables were found!", CTDBinary.hex = Strings, !0//I HAVE TO CREATE A SECTION!!
        },
        //Function used for saving the modded text as a new BAR file. OK
        SaveCTD = function(BARBinary) {
            var i, InfoCount, o, BARReader = new jDataView(BARBinary.rawData, void 0, void 0, !0),
                Output = [BARReader.getBytes(16)],
                Length = 16,
                Count = (BARReader.seek(4), BARReader.getUint32()),
                changes = 0;
                //For each file we need to do it.
            for (i = -1, InfoCount = 4 * Count; ++i < InfoCount; Length += 4) Output.push(13);
                //Then for each file again we need to write each infos(since we have 4 entries, Count*4 = infosCount.)
            for (i = -1, InfoCount = 0; ++i < Count;) BARReader.seek(16 * (i + 1)), Output[++InfoCount] = SwapBytes(o = BARReader.getUint32()), Output[++InfoCount] = BARReader.getBytes(4), Output[++InfoCount] = SwapBytes(Length), 2 === o && "object" == typeof BARBinary.sections[i] && "string" == typeof BARBinary.sections[i].hex && BARBinary.sections[i].changed ? (++changes, Output.push(o = s(BARBinary.sections[i]))) : (o = [BARReader.getUint32(), BARReader.getUint32()], 0 !== o[1] ? (BARReader.seek(o[0]), Output.push(o = BARReader.getBytes(o[1]))) : o = []), Output[++InfoCount] = SwapBytes(o.length), Length += o.length, i + 1 !== Count && 16 !== (o = 16 - Length % 16) && (Output.push(new Uint8Array(o)), Length += o);
            if (0 === changes && !confirm("No sections have been changed!\nSave the file unmodified?")) throw Error("Aborted");
            return Output
        };
    AbstractEditor.settings.fileTypes.CTD = {
        fileMask: /^.*\.ctd$/i,//KH2
        parseFile: ParseCTD,
        getData: SaveCTD
    };
    //Related to automated translation, kind of great if you don't have a japanese slave y'can borrow. Or if you want to laugh.

    window.gG = AbstractEditor.init()
}();