//Too lazy to deobfuscate 4 now
//Basically: jsDataView and FileSaver.js


! function (t) {
    "use strict";

    function e(t, e) {
        return !e && t instanceof Array ? t : Array.prototype.slice.call(t)
    }

    function n(t, e) {
        return void 0 !== t ? t : e
    }

    function i(t, e, r, s) {
        if (t instanceof i) {
            var f = t.slice(e, e + r);
            return f._littleEndian = n(s, f._littleEndian), f
        }
        if (!(this instanceof i)) return new i(t, e, r, s);
        if (this.buffer = t = i.wrapBuffer(t), this._isArrayBuffer = a.ArrayBuffer && t instanceof ArrayBuffer, this._isPixelData = a.PixelData && t instanceof CanvasPixelArray, this._isDataView = a.DataView && this._isArrayBuffer, this._isNodeBuffer = a.NodeBuffer && t instanceof Buffer, !(this._isNodeBuffer || this._isArrayBuffer || this._isPixelData || t instanceof Array)) throw new TypeError("jDataView buffer has an incompatible type");
        this._littleEndian = !!s;
        var o = "byteLength" in t ? t.byteLength : t.length;
        this.byteOffset = e = n(e, 0), this.byteLength = r = n(r, o - e), this._isDataView ? this._view = new DataView(t, e, r) : this._checkBounds(e, r, o), this._engineAction = this._isDataView ? this._dataViewAction : this._isNodeBuffer ? this._nodeBufferAction : this._isArrayBuffer ? this._arrayBufferAction : this._arrayAction
    }

    function r(t) {
        if (a.NodeBuffer) return new Buffer(t, "binary");
        for (var e = a.ArrayBuffer ? Uint8Array : Array, n = new e(t.length), i = 0, r = t.length; r > i; i++) n[i] = 255 & t.charCodeAt(i);
        return n
    }

    function s(t) {
        return t >= 0 && 31 > t ? 1 << t : s[t] || (s[t] = Math.pow(2, t))
    }

    function f(t, e) {
        this.lo = t, this.hi = e
    }

    function o() {
        f.apply(this, arguments)
    }
    var a = {
        NodeBuffer: "Buffer" in t && "readInt16LE" in Buffer.prototype,
        DataView: "DataView" in t && ("getFloat64" in DataView.prototype || "getFloat64" in new DataView(new ArrayBuffer(1))),
        ArrayBuffer: "ArrayBuffer" in t,
        PixelData: "CanvasPixelArray" in t && "ImageData" in t && "document" in t
    };
    if (a.NodeBuffer && ! function (t) {
        try {
            t.writeFloatLE(1 / 0, 0)
        } catch (t) {
            a.NodeBuffer = !1
        }
    }(new Buffer(4)), a.PixelData) {
        var u = function (t, e) {
            var n = u.context2d.createImageData((t + 3) / 4, 1).data;
            if (n.byteLength = t, void 0 !== e)
                for (var i = 0; t > i; i++) n[i] = e[i];
            return n
        };
        u.context2d = document.createElement("canvas").getContext("2d")
    }
    var h = {
            Int8: 1,
            Int16: 2,
            Int32: 4,
            Uint8: 1,
            Uint16: 2,
            Uint32: 4,
            Float32: 4,
            Float64: 8
        },
        c = {
            Int8: "Int8",
            Int16: "Int16",
            Int32: "Int32",
            Uint8: "UInt8",
            Uint16: "UInt16",
            Uint32: "UInt32",
            Float32: "Float",
            Float64: "Double"
        };
    i.wrapBuffer = function (t) {
        switch (typeof t) {
        case "number":
            if (a.NodeBuffer) t = new Buffer(t), t.fill(0);
            else if (a.ArrayBuffer) t = new Uint8Array(t).buffer;
            else if (a.PixelData) t = u(t);
            else {
                t = new Array(t);
                for (var n = 0; n < t.length; n++) t[n] = 0
            }
            return t;
        case "string":
            t = r(t);
        default:
            return "length" in t && !(a.NodeBuffer && t instanceof Buffer || a.ArrayBuffer && t instanceof ArrayBuffer || a.PixelData && t instanceof CanvasPixelArray) && (a.NodeBuffer ? t = new Buffer(t) : a.ArrayBuffer ? t instanceof ArrayBuffer || (t = new Uint8Array(t).buffer, t instanceof ArrayBuffer || (t = new Uint8Array(e(t, !0)).buffer)) : t = a.PixelData ? u(t.length, t) : e(t)), t
        }
    }, i.createBuffer = function () {
        return i.wrapBuffer(arguments)
    }, i.Uint64 = f, f.prototype = {
        valueOf: function () {
            return this.lo + s(32) * this.hi
        },
        toString: function () {
            return Number.prototype.toString.apply(this.valueOf(), arguments)
        }
    }, f.fromNumber = function (t) {
        var e = Math.floor(t / s(32)),
            n = t - e * s(32);
        return new f(n, e)
    }, i.Int64 = o, o.prototype = "create" in Object ? Object.create(f.prototype) : new f, o.prototype.valueOf = function () {
        return this.hi < s(31) ? f.prototype.valueOf.apply(this, arguments) : -(s(32) - this.lo + s(32) * (s(32) - 1 - this.hi))
    }, o.fromNumber = function (t) {
        var e, n;
        if (t >= 0) {
            var i = f.fromNumber(t);
            e = i.lo, n = i.hi
        } else n = Math.floor(t / s(32)), e = t - n * s(32), n += s(32);
        return new o(e, n)
    }, i.prototype = {
        _offset: 0,
        _bitOffset: 0,
        compatibility: a,
        _checkBounds: function (t, e, i) {
            if ("number" != typeof t) throw new TypeError("Offset is not a number.");
            if ("number" != typeof e) throw new TypeError("Size is not a number.");
            if (0 > e) throw new RangeError("Length is negative.");
            if (0 > t || t + e > n(i, this.byteLength)) throw new RangeError("Offsets are out of bounds.")
        },
        _action: function (t, e, i, r, s) {
            return this._engineAction(t, e, n(i, this._offset), n(r, this._littleEndian), s)
        },
        _dataViewAction: function (t, e, n, i, r) {
            return this._offset = n + h[t], e ? this._view["get" + t](n, i) : this._view["set" + t](n, r, i)
        },
        _nodeBufferAction: function (t, e, n, i, r) {
            this._offset = n + h[t];
            var s = c[t] + ("Int8" === t || "Uint8" === t ? "" : i ? "LE" : "BE");
            return n += this.byteOffset, e ? this.buffer["read" + s](n) : this.buffer["write" + s](r, n)
        },
        _arrayBufferAction: function (e, i, r, s, f) {
            var o, a = h[e],
                u = t[e + "Array"];
            if (s = n(s, this._littleEndian), 1 === a || (this.byteOffset + r) % a === 0 && s) return o = new u(this.buffer, this.byteOffset + r, 1), this._offset = r + a, i ? o[0] : o[0] = f;
            var c = new Uint8Array(i ? this.getBytes(a, r, s, !0) : a);
            return o = new u(c.buffer, 0, 1), i ? o[0] : (o[0] = f, this._setBytes(r, c, s), void 0)
        },
        _arrayAction: function (t, e, n, i, r) {
            return e ? this["_get" + t](n, i) : this["_set" + t](n, r, i)
        },
        _getBytes: function (t, i, r) {
            r = n(r, this._littleEndian), i = n(i, this._offset), t = n(t, this.byteLength - i), this._checkBounds(i, t), i += this.byteOffset, this._offset = i - this.byteOffset + t;
            var s = this._isArrayBuffer ? new Uint8Array(this.buffer, i, t) : (this.buffer.slice || Array.prototype.slice).call(this.buffer, i, i + t);
            return r || 1 >= t ? s : e(s).reverse()
        },
        getBytes: function (t, i, r, s) {
            var f = this._getBytes(t, i, n(r, !0));
            return s ? e(f) : f
        },
        _setBytes: function (t, i, r) {
            var s = i.length;
            if (0 !== s) {
                if (r = n(r, this._littleEndian), t = n(t, this._offset), this._checkBounds(t, s), !r && s > 1 && (i = e(i, !0).reverse()), t += this.byteOffset, this._isArrayBuffer) new Uint8Array(this.buffer, t, s).set(i);
                else if (this._isNodeBuffer) new Buffer(i).copy(this.buffer, t);
                else
                    for (var f = 0; s > f; f++) this.buffer[t + f] = i[f];
                this._offset = t - this.byteOffset + s
            }
        },
        setBytes: function (t, e, i) {
            this._setBytes(t, e, n(i, !0))
        },
        getString: function (t, e, i) {
            if (this._isNodeBuffer) return e = n(e, this._offset), t = n(t, this.byteLength - e), this._checkBounds(e, t), this._offset = e + t, this.buffer.toString(i || "binary", this.byteOffset + e, this.byteOffset + this._offset);
            var r = this._getBytes(t, e, !0),
                s = "";
            t = r.length;
            for (var f = 0; t > f; f++) s += String.fromCharCode(r[f]);
            return "utf8" === i && (s = decodeURIComponent(escape(s))), s
        },
        setString: function (t, e, i) {
            return this._isNodeBuffer ? (t = n(t, this._offset), this._checkBounds(t, e.length), this._offset = t + this.buffer.write(e, this.byteOffset + t, i || "binary"), void 0) : ("utf8" === i && (e = unescape(encodeURIComponent(e))), this._setBytes(t, r(e), !0), void 0)
        },
        getChar: function (t) {
            return this.getString(1, t)
        },
        setChar: function (t, e) {
            this.setString(t, e)
        },
        tell: function () {
            return this._offset
        },
        seek: function (t) {
            return this._checkBounds(t, 0), this._offset = t
        },
        skip: function (t) {
            return this.seek(this._offset + t)
        },
        slice: function (t, e, r) {
            function s(t, e) {
                return 0 > t ? t + e : t
            }
            return t = s(t, this.byteLength), e = s(n(e, this.byteLength), this.byteLength), r ? new i(this.getBytes(e - t, t, !0, !0), void 0, void 0, this._littleEndian) : new i(this.buffer, this.byteOffset + t, e - t, this._littleEndian)
        },
        alignBy: function (t) {
            return this._bitOffset = 0, 1 !== n(t, 1) ? this.skip(t - (this._offset % t || t)) : this._offset
        },
        _getFloat64: function (t, e) {
            var n = this._getBytes(8, t, e),
                i = 1 - 2 * (n[7] >> 7),
                r = ((n[7] << 1 & 255) << 3 | n[6] >> 4) - 1023,
                f = (15 & n[6]) * s(48) + n[5] * s(40) + n[4] * s(32) + n[3] * s(24) + n[2] * s(16) + n[1] * s(8) + n[0];
            return 1024 === r ? 0 !== f ? 0 / 0 : 1 / 0 * i : -1023 === r ? i * f * s(-1074) : i * (1 + f * s(-52)) * s(r)
        },
        _getFloat32: function (t, e) {
            var n = this._getBytes(4, t, e),
                i = 1 - 2 * (n[3] >> 7),
                r = (n[3] << 1 & 255 | n[2] >> 7) - 127,
                f = (127 & n[2]) << 16 | n[1] << 8 | n[0];
            return 128 === r ? 0 !== f ? 0 / 0 : 1 / 0 * i : -127 === r ? i * f * s(-149) : i * (1 + f * s(-23)) * s(r)
        },
        _get64: function (t, e, i) {
            i = n(i, this._littleEndian), e = n(e, this._offset);
            for (var r = i ? [0, 4] : [4, 0], s = 0; 2 > s; s++) r[s] = this.getUint32(e + r[s], i);
            return this._offset = e + 8, new t(r[0], r[1])
        },
        getInt64: function (t, e) {
            return this._get64(o, t, e)
        },
        getUint64: function (t, e) {
            return this._get64(f, t, e)
        },
        _getInt32: function (t, e) {
            var n = this._getBytes(4, t, e);
            return n[3] << 24 | n[2] << 16 | n[1] << 8 | n[0]
        },
        _getUint32: function (t, e) {
            return this._getInt32(t, e) >>> 0
        },
        _getInt16: function (t, e) {
            return this._getUint16(t, e) << 16 >> 16
        },
        _getUint16: function (t, e) {
            var n = this._getBytes(2, t, e);
            return n[1] << 8 | n[0]
        },
        _getInt8: function (t) {
            return this._getUint8(t) << 24 >> 24
        },
        _getUint8: function (t) {
            return this._getBytes(1, t)[0]
        },
        _getBitRangeData: function (t, e) {
            var i = (n(e, this._offset) << 3) + this._bitOffset,
                r = i + t,
                s = i >>> 3,
                f = r + 7 >>> 3,
                o = this._getBytes(f - s, s, !0),
                a = 0;
            (this._bitOffset = 7 & r) && (this._bitOffset -= 8);
            for (var u = 0, h = o.length; h > u; u++) a = a << 8 | o[u];
            return {
                start: s,
                bytes: o,
                wideValue: a
            }
        },
        getSigned: function (t, e) {
            var n = 32 - t;
            return this.getUnsigned(t, e) << n >> n
        },
        getUnsigned: function (t, e) {
            var n = this._getBitRangeData(t, e).wideValue >>> -this._bitOffset;
            return 32 > t ? n & ~(-1 << t) : n
        },
        _setBinaryFloat: function (t, e, n, i, r) {
            var f, o, a = 0 > e ? 1 : 0,
                u = ~(-1 << i - 1),
                h = 1 - u;
            0 > e && (e = -e), 0 === e ? (f = 0, o = 0) : isNaN(e) ? (f = 2 * u + 1, o = 1) : 1 / 0 === e ? (f = 2 * u + 1, o = 0) : (f = Math.floor(Math.log(e) / Math.LN2), f >= h && u >= f ? (o = Math.floor((e * s(-f) - 1) * s(n)), f += u) : (o = Math.floor(e / s(h - n)), f = 0));
            for (var c = []; n >= 8;) c.push(o % 256), o = Math.floor(o / 256), n -= 8;
            for (f = f << n | o, i += n; i >= 8;) c.push(255 & f), f >>>= 8, i -= 8;
            c.push(a << i | f), this._setBytes(t, c, r)
        },
        _setFloat32: function (t, e, n) {
            this._setBinaryFloat(t, e, 23, 8, n)
        },
        _setFloat64: function (t, e, n) {
            this._setBinaryFloat(t, e, 52, 11, n)
        },
        _set64: function (t, e, i, r) {
            i instanceof t || (i = t.fromNumber(i)), r = n(r, this._littleEndian), e = n(e, this._offset);
            var s = r ? {
                lo: 0,
                hi: 4
            } : {
                lo: 4,
                hi: 0
            };
            for (var f in s) this.setUint32(e + s[f], i[f], r);
            this._offset = e + 8
        },
        setInt64: function (t, e, n) {
            this._set64(o, t, e, n)
        },
        setUint64: function (t, e, n) {
            this._set64(f, t, e, n)
        },
        _setUint32: function (t, e, n) {
            this._setBytes(t, [255 & e, e >>> 8 & 255, e >>> 16 & 255, e >>> 24], n)
        },
        _setUint16: function (t, e, n) {
            this._setBytes(t, [255 & e, e >>> 8 & 255], n)
        },
        _setUint8: function (t, e) {
            this._setBytes(t, [255 & e])
        },
        setUnsigned: function (t, e, n) {
            var i = this._getBitRangeData(n, t),
                r = i.wideValue,
                s = i.bytes;
            r &= ~(~(-1 << n) << -this._bitOffset), r |= (32 > n ? e & ~(-1 << n) : e) << -this._bitOffset;
            for (var f = s.length - 1; f >= 0; f--) s[f] = 255 & r, r >>>= 8;
            this._setBytes(i.start, s, !0)
        }
    };
    var l = i.prototype;
    for (var y in h)! function (t) {
        l["get" + t] = function (e, n) {
            return this._action(t, !0, e, n)
        }, l["set" + t] = function (e, n, i) {
            this._action(t, !1, e, i, n)
        }
    }(y);
    l._setInt32 = l._setUint32, l._setInt16 = l._setUint16, l._setInt8 = l._setUint8, l.setSigned = l.setUnsigned;
    for (var _ in l) "set" === _.slice(0, 3) && ! function (t) {
        l["write" + t] = function () {
            Array.prototype.unshift.call(arguments, void 0), this["set" + t].apply(this, arguments)
        }
    }(_.slice(3));
    if ("undefined" != typeof module && "object" == typeof module.exports) module.exports = i;
    else if ("function" == typeof define && define.amd) define([], function () {
        return i
    });
    else {
        var d = t.jDataView;
        (t.jDataView = i).noConflict = function () {
            return t.jDataView = d, this
        }
    }
}(function () {
    return this
}());
var saveAs = saveAs || "undefined" != typeof navigator && navigator.msSaveOrOpenBlob && navigator.msSaveOrOpenBlob.bind(navigator) || function (t) {
    "use strict";
    var e = t.document,
        n = function () {
            return t.URL || t.webkitURL || t
        },
        i = t.URL || t.webkitURL || t,
        r = e.createElementNS("http://www.w3.org/1999/xhtml", "a"),
        s = !t.externalHost && "download" in r,
        f = t.webkitRequestFileSystem,
        o = t.requestFileSystem || f || t.mozRequestFileSystem,
        a = function (e) {
            (t.setImmediate || t.setTimeout)(function () {
                throw e
            }, 0)
        },
        u = "application/octet-stream",
        h = 0,
        c = [],
        l = function () {
            for (var t = c.length; t--;) {
                var e = c[t];
                "string" == typeof e ? i.revokeObjectURL(e) : e.remove()
            }
            c.length = 0
        },
        y = function (t, e, n) {
            e = [].concat(e);
            for (var i = e.length; i--;) {
                var r = t["on" + e[i]];
                if ("function" == typeof r) try {
                    r.call(t, n || t)
                } catch (t) {
                    a(t)
                }
            }
        },
        _ = function (i, a) {
            var l, _, d, g = this,
                w = i.type,
                v = !1,
                B = function () {
                    var t = n().createObjectURL(i);
                    return c.push(t), t
                },
                p = function () {
                    y(g, "writestart progress write writeend".split(" "))
                },
                b = function () {
                    (v || !l) && (l = B(i)), _ ? _.location.href = l : window.open(l, "_blank"), g.readyState = g.DONE, p()
                },
                m = function (t) {
                    return function () {
                        return g.readyState !== g.DONE ? t.apply(this, arguments) : void 0
                    }
                },
                A = {
                    create: !0,
                    exclusive: !1
                };
            if (g.readyState = g.INIT, a || (a = "download"), s) {
                l = B(i), e = t.document, r = e.createElementNS("http://www.w3.org/1999/xhtml", "a"), r.href = l, r.download = a;
                var U = e.createEvent("MouseEvents");
                return U.initMouseEvent("click", !0, !1, t, 0, 0, 0, 0, 0, !1, !1, !1, !1, 0, null), r.dispatchEvent(U), g.readyState = g.DONE, p(), void 0
            }
            return t.chrome && w && w !== u && (d = i.slice || i.webkitSlice, i = d.call(i, 0, i.size, u), v = !0), f && "download" !== a && (a += ".download"), (w === u || f) && (_ = t), o ? (h += i.size, o(t.TEMPORARY, h, m(function (t) {
                t.root.getDirectory("saved", A, m(function (t) {
                    var e = function () {
                        t.getFile(a, A, m(function (t) {
                            t.createWriter(m(function (e) {
                                e.onwriteend = function (e) {
                                    _.location.href = t.toURL(), c.push(t), g.readyState = g.DONE, y(g, "writeend", e)
                                }, e.onerror = function () {
                                    var t = e.error;
                                    t.code !== t.ABORT_ERR && b()
                                }, "writestart progress write abort".split(" ").forEach(function (t) {
                                    e["on" + t] = g["on" + t]
                                }), e.write(i), g.abort = function () {
                                    e.abort(), g.readyState = g.DONE
                                }, g.readyState = g.WRITING
                            }), b)
                        }), b)
                    };
                    t.getFile(a, {
                        create: !1
                    }, m(function (t) {
                        t.remove(), e()
                    }), m(function (t) {
                        t.code === t.NOT_FOUND_ERR ? e() : b()
                    }))
                }), b)
            }), b), void 0) : (b(), void 0)
        },
        d = _.prototype,
        g = function (t, e) {
            return new _(t, e)
        };
    return d.abort = function () {
        var t = this;
        t.readyState = t.DONE, y(t, "abort")
    }, d.readyState = d.INIT = 0, d.WRITING = 1, d.DONE = 2, d.error = d.onwritestart = d.onprogress = d.onwrite = d.onabort = d.onerror = d.onwriteend = null, t.addEventListener("unload", l, !1), g
}(this.self || this.window || this.content);
"undefined" != typeof module && (module.exports = saveAs);